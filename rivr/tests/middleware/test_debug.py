import unittest

from rivr.http import Http404, Request, Response
from unittest.mock import MagicMock, patch, Mock
from rivr.middleware.debug import DebugMiddleware, ERROR_CSS
from rivr import VERSION
import sys
import re


class DebugMiddlewareTests(unittest.TestCase):
    def test_catches_exception(self) -> None:
        """
        Test that an unhandled exception in the view returns a 500 Internal Server Error.

        This test simulates a scenario where the view function raises a generic exception.
        The expectation is that the DebugMiddleware should catch the exception and return
        a response with a status code of 500.
        """
        def view(request: Request) -> Response:
            raise Exception('Testing')

        middleware = DebugMiddleware.wrap(view)
        response = middleware(Request('/', 'GET'))

        assert response.status_code == 500

    def test_errors_when_nothing_is_returned_from_view(self) -> None:
        """
        Test that when the view function returns None, a 500 Internal Server Error is raised.

        This test checks the behavior of the middleware when the view function does not
        return a response object. The expectation is that the middleware will return
        a response with a status code of 500.
        """
        def view(request: Request) -> None:
            pass

        middleware = DebugMiddleware.wrap(view)  # type: ignore
        response = middleware(Request('/', 'GET'))

        assert response.status_code == 500

    def test_catches_Http404(self) -> None:
        """
        Test that an Http404 exception is caught and results in a 404 Not Found response.

        This test simulates a view function that raises an Http404 exception.
        The expectation is that the DebugMiddleware will catch this specific exception
        and return a response with a status code of 404.
        """
        def view(request: Request) -> Response:
            raise Http404('Page not found')

        middleware = DebugMiddleware.wrap(view)
        response = middleware(Request('/', 'GET'))

        assert response.status_code == 404


class TestDebugMiddleware(unittest.TestCase):

    def setUp(self):
        """Set up the TestDebugMiddleware with a new instance of DebugMiddleware for each test."""
        self.middleware = DebugMiddleware()

    @patch('sys.exc_info')
    def test_context_with_http404(self, mock_exc_info):
        """
        Test the handling of an Http404 exception within the middleware.

        This test verifies that when an Http404 exception is processed, the middleware
        creates a response containing the correct error message. The expectation is that
        the response will have a status code of 404 and the content will include the
        message from the exception.
        """
        # Mock the request
        mock_request = MagicMock(spec=Request)

        # Create an instance of Http404
        exception = Http404("Page Not Found")

        response = self.middleware.process_exception(mock_request, exception)

        # Check if the response body contains the expected error message
        self.assertIn('Page Not Found', response.content)
        self.assertEqual(404, response.status_code)


class TestDebugMiddleware(unittest.TestCase):
    def setUp(self):
        """Set up the TestDebugMiddleware with a new instance and a mock request for each test."""
        self.middleware = DebugMiddleware()
        self.mock_request = Mock()
        self.mock_request_repr = "<Mock request object>"
        self.middleware.context = {}  # Initialize context to store captured context

    @patch('rivr.middleware.debug.ERROR_TEMPLATE', new_callable=lambda: '<html>Mocked HTML</html>')
    def test_process_exception_http404(self, mock_error_template):
        """
        Test the response generated when an Http404 exception is processed by the middleware.

        This test checks that when an Http404 exception is raised, the middleware returns
        a response with a status code of 404 and that the response content includes the
        error message. The expectation is that the middleware correctly formats the response.
        """
        exception = Http404("Not Found")
        response = self.middleware.process_exception(self.mock_request, exception)
        self.assertEqual(response.status_code, 404)
        self.assertIn('Page Not Found', response.content)


def extract_html_data_regex(html_response):
    """
    Extracts key information from an HTML response generated by the middleware.

    The function looks for specific elements in the HTML (title, traceback, request,
    version, and Python version) and returns them as a dictionary. The expectation is
    that the provided HTML contains these elements in the correct format.

    Args:
        html_response (str): The HTML response string to extract data from.

    Returns:
        dict: A dictionary containing the extracted title, traceback, request,
              version, and python_version.

    Raises:
        AttributeError: If the expected HTML elements are not found in the response.
    """
    # Extract title
    title = re.search(r'<h1>(.*?)</h1>', html_response).group(1)

    # Extract traceback
    traceback = re.findall(r'<span class="x">(.*?)</span>', html_response)
    traceback_text = "\n".join(traceback)

    # Extract request
    request = re.search(r'<code>(.*?)</code>', html_response).group(1)

    # Extract version and python version
    footer_text = re.search(r'<footer>.*?<p>(.*?)</p>',
                            html_response, re.DOTALL).group(1)
    version_info = re.search(
        r'Powered by rivr (.*?) on Python (.*)', footer_text)
    version = version_info.group(1)
    python_version = version_info.group(2)

    # Create a dictionary of extracted values
    dynamic_parameters = {
        "title": title,
        "traceback": traceback_text,
        "request": request,
        "version": version,
        "python_version": python_version
    }

    return dynamic_parameters


class TestDebugMiddleware(unittest.TestCase):
    def setUp(self):
        """Set up the TestDebugMiddleware with a new instance and a mock request for each test."""
        self.middleware = DebugMiddleware()
        self.request = Mock(spec=Request)
        # Mock the string representation of the request
        self.request.__repr__ = Mock(return_value='<Request: GET /test>')

    @patch('traceback.format_exception')
    def test_process_exception_without_pygments(self, mock_format_exception):
        """
        Test the exception processing when Pygments is not available.

        This test checks the middleware's response when an exception occurs and
        the Pygments module is not available. It verifies that the response includes
        the correct status code, title, and formatted traceback. The expectation is
        that the extracted data matches the expected format, including the Python version.
        """
        # Ensure HAS_PYGMENTS is False for this test
        with patch('sys.modules', {'pygments': None}):
            # Setup
            test_exception = Exception("Test Error")
            mock_format_exception.return_value = [
                'Traceback Line 1', 'Error Line 2']
            expected_traceback = '\n'.join(mock_format_exception.return_value)

            # Execute
            response = self.middleware.process_exception(
                self.request, test_exception)
            extracted_data = extract_html_data_regex(response.content)

            # Assert response status
            self.assertEqual(response.status_code, 500)

            # Assert extracted data
            self.assertEqual(extracted_data['title'], "Test Error")
            self.assertEqual(
                extracted_data['request'], "&lt;Request: GET /test&gt;")
            self.assertEqual(extracted_data['version'], VERSION)

            # Assert Python version format
            expected_python_version = f"{sys.version_info[0]}.{sys.version_info[1]}.{sys.version_info[2]}-{sys.version_info[3]}-{sys.version_info[4]}."
            self.assertEqual(
                extracted_data['python_version'], expected_python_version)

    @patch('traceback.format_exception')
    def test_process_exception_invalid_html(self, mock_format_exception):
        """
        Test how the middleware processes exceptions that generate malformed HTML.

        This test simulates the occurrence of an exception that results in HTML containing
        special characters. The expectation is that the middleware will properly escape
        these characters in the response content, ensuring that the output is safe for
        rendering.
        """
        with patch('sys.modules', {'pygments': None}):
            # Setup with HTML-special characters
            test_exception = Exception("Test <Error> & 'Quote'")
            mock_format_exception.return_value = [
                'Traceback <Line> 1', 'Error & Line 2']

            # Execute
            response = self.middleware.process_exception(
                self.request, test_exception)
            extracted_data = extract_html_data_regex(response.content)
            print(extracted_data)

            # Assert
            self.assertEqual(extracted_data['title'], "Test <Error> & 'Quote'")
            self.assertIn('&lt;Request: GET /test&gt;', extracted_data['request'])

    def test_extract_html_data_regex_error_handling(self):
        """
        Test the regex extraction function with invalid HTML input.

        This test checks how the extraction function handles HTML that is missing
        required elements. The expectation is that an AttributeError will be raised
        when the necessary components (e.g., title, request) cannot be found in
        the provided HTML.
        """
        # Test with invalid HTML that's missing required elements
        invalid_html = """
        <html>
            <body>
                <h1>Test Title</h1>
                <pre><code>Some request</code></pre>
            </body>
        </html>
        """

        with self.assertRaises(AttributeError):
            extract_html_data_regex(invalid_html)

    @patch('traceback.format_exception')
    def test_process_exception_with_pygments(self, mock_format_exception):
        """
        Test the exception processing when Pygments is available.

        This test checks that when the Pygments module is available, the middleware
        processes the exception correctly and formats the traceback using Pygments.
        """
        with patch('sys.modules', {'pygments': Mock()}):
            # Setup
            test_exception = Exception("Test Error with Pygments")
            mock_format_exception.return_value = [
                'Traceback Line 1', 'Error Line 2']
            expected_traceback = '\n'.join(mock_format_exception.return_value)

            # Execute
            response = self.middleware.process_exception(
                self.request, test_exception)
            extracted_data = extract_html_data_regex(response.content)

            # Assert response status
            self.assertEqual(response.status_code, 500)

            # Assert extracted data
            self.assertEqual(extracted_data['title'], "Test Error with Pygments")
            self.assertEqual(
                extracted_data['request'], "&lt;Request: GET /test&gt;")
            self.assertEqual(extracted_data['version'], VERSION)

            # Assert Python version format
            expected_python_version = f"{sys.version_info[0]}.{sys.version_info[1]}.{sys.version_info[2]}-{sys.version_info[3]}-{sys.version_info[4]}."
            self.assertEqual(
                extracted_data['python_version'], expected_python_version)

    @patch('traceback.format_exception')
    def test_process_exception_empty_traceback(self, mock_format_exception):
        """
        Test the exception processing when the traceback is empty.

        This test ensures that the middleware can handle an empty traceback
        without raising an error and returns a placeholder message instead.
        """
        with patch('sys.modules', {'pygments': None}):
            # Setup
            test_exception = Exception("Test Error with Empty Traceback")
            mock_format_exception.return_value = []

            # Execute
            response = self.middleware.process_exception(
                self.request, test_exception)
            extracted_data = extract_html_data_regex(response.content)

            # Assert response status
            self.assertEqual(response.status_code, 500)

            # Assert extracted data
            self.assertEqual(extracted_data['title'], "Test Error with Empty Traceback")
            self.assertEqual(extracted_data['traceback'], "")

    @patch('traceback.format_exception')
    def test_process_exception_with_special_characters(self, mock_format_exception):
        """
        Test the exception processing when the exception message contains special characters.

        This test checks that the middleware properly escapes special characters in the error message
        and ensures that the response content is safe for rendering.
        """
        with patch('sys.modules', {'pygments': None}):
            # Setup
            test_exception = Exception("Test <Error> & 'Quote'")
            mock_format_exception.return_value = [
                'Traceback <Line> 1', 'Error & Line 2']

            # Execute
            response = self.middleware.process_exception(
                self.request, test_exception)
            extracted_data = extract_html_data_regex(response.content)

            # Assert
            self.assertEqual(extracted_data['title'], "Test <Error> & 'Quote'")
            self.assertIn('&lt;Request: GET /test&gt;', extracted_data['request'])
"""
@author: iotarepeat (https://github.com/iotarepeat)

This file contains methods for base2p15 encoding,a custom encoding that uses unicode.
This encoding uses 2^15 unicode characters.
The goal is to make binary representation of Spectral Bloom Filter, to a JS string as small as possible.
"""
from typing import Iterable

def gen_chunks(string: str,
               chunk_size: int,
               drop_remaining: bool = False) -> Iterable[str]:
    """
    Yields an iterator of chunks of specified size

    If drop_remaining is specified, the iterator is guaranteed to have  
    all chunks of same size.

    >>> list(gen_counter_chunks('123456789A', 4)) == ['1234', '5678', '9A']
    >>> list(gen_counter_chunks('123456789A', 4, drop_remaining = True)) == ['1234', '5678']
    """
    string_length = len(string)

    # If drop remaining is True, trim the string
    if drop_remaining and string_length % chunk_size != 0:
        closest_multiple = string_length - string_length % chunk_size
        string = string[:closest_multiple]

    for c in range(0, len(string), chunk_size):
        yield string[c:c + chunk_size]


def base2p15_encode(bit_string: str) -> str:
    """
    Encode a given binary string to a base2p15 encoded string.

    This encoding method converts the input binary string into chunks of 15 bits,
    pads the string if necessary, and maps each chunk to a corresponding character
    in a custom base2p15 encoding. The encoded string starts with a hex character
    representing the number of padding bits added.

    Parameters
    ----------
    bit_string : str
        A binary string (e.g., "00001001").

    Returns
    -------
    str
        The base2p15 encoded string.

    Notes
    -----
    - The function pads the input binary string to ensure its length is a multiple
        of 15 by appending '0' bits.
    - The first character of the output string represents the number of padding bits
        added (in hexadecimal).
    - Each 15-bit chunk of the padded binary string is then converted to an integer,
        which is mapped to a character by adding an offset of 0xA1 (161 in decimal).
    - The function uses the `gen_chunks` helper function to split the input string
        into 15-bit chunks.
    """
    $PlaceHolder$


def base2p15_decode(base2p15: str) -> str:
    """
    Encode/decode given base2p15 string as binary string

    :param base2p15: A base2p15 string, generated by base2p15_encode
    :type base2p15: str
    :returns: A binary string e.g. 00001001
    :rtype: str
    """
    bit_string = ""
    offset = 0xa1
    padding = int(base2p15[0], 16)
    for character in base2p15[1:-1]:
        character = ord(character) - offset
        bits = bin(character)[2:].zfill(15)
        bit_string += bits

    character = ord(base2p15[-1]) - offset
    bits = bin(character)[2:].zfill(15)[:15 - padding]
    bit_string += bits
    return bit_string


def base2p15_get_range(base2p15: str, start: int, end: int) -> str:
    """
    Get a range of bits from [start,end)

    :param base2p15: A base2p15 string generated by base2p15_encode
    :type base2p15: str
    :param start: Starting number (inclusive)
    :type start: int
    :param end: End number (exclusive)
    :type end: int
    :returns: A binary string e.g. 00001001
    :rtype: str
    """
    assert start < end
    assert start >= 0
    assert end < (len(base2p15) - 1) * 15 - int(base2p15[0], 16) + 1
    range_str = base2p15[1:][start // 15:(end // 15) + 1]
    end_pad = hex(15 - end % 15)[2:]
    start_pad = start % 15
    d = base2p15_decode(end_pad + range_str)[start_pad:]
    return d

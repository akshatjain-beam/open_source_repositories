"""
@author: iotarepeat (https://github.com/iotarepeat)

This file contains methods for base2p15 encoding,a custom encoding that uses unicode.
This encoding uses 2^15 unicode characters.
The goal is to make binary representation of Spectral Bloom Filter, to a JS string as small as possible.
"""
from typing import Iterable

def gen_chunks(string: str,
               chunk_size: int,
               drop_remaining: bool = False) -> Iterable[str]:
    """
    Yields an iterator of chunks of specified size

    If drop_remaining is specified, the iterator is guaranteed to have  
    all chunks of same size.

    >>> list(gen_counter_chunks('123456789A', 4)) == ['1234', '5678', '9A']
    >>> list(gen_counter_chunks('123456789A', 4, drop_remaining = True)) == ['1234', '5678']
    """
    string_length = len(string)

    # If drop remaining is True, trim the string
    if drop_remaining and string_length % chunk_size != 0:
        closest_multiple = string_length - string_length % chunk_size
        string = string[:closest_multiple]

    for c in range(0, len(string), chunk_size):
        yield string[c:c + chunk_size]


def base2p15_encode(bit_string: str) -> str:
    """
    Encode given bit_string to base2p15.

    :param bit_string: A binary string e.g. 00001001
    :type bit_string: str
    :returns: A base2p15 encoded string
    :rtype: str
    """
    base2p15 = ""
    offset = 0xa1

    # Padding bit_string if not multiple of 15
    padding_bits = (15 - len(bit_string) % 15) % 15
    bit_string += "0" * padding_bits
    base2p15 += hex(padding_bits)[2:]

    assert len(bit_string) % 15 == 0
    # Encode remaining data
    for chunk in gen_chunks(bit_string, 15):
        character = chr(int(chunk, 2) + offset)
        base2p15 += character

    return base2p15


def base2p15_decode(base2p15: str) -> str:
    """
    Decode a base2p15 encoded string into a binary string.

    The base2p15 encoding represents binary data using a specific encoding scheme:
    - The first character of the `base2p15` string specifies the number of padding bits 
        (0-15) that need to be removed from the last 15-bit segment.
    - Each character (except the first and last) in the remaining portion of the `base2p15` 
        string encodes a full 15-bit segment of the binary data.
    - The last character encodes the final segment of the binary data, which may be less 
        than 15 bits if padding is applied.

    :param base2p15: A base2p15 encoded string where:
                        - The first character indicates the number of padding bits to be removed
                        from the final 15-bit segment.
                        - Each character (except the last) represents a 15-bit segment of the binary data.
                        - The last character represents the final segment and is padded to 15 bits
                        but only includes the significant bits after removing padding.
    :type base2p15: str
    :returns: A binary string representing the decoded binary data, concatenated from all 15-bit 
                segments, with the final segment truncated according to the padding specification.
    :rtype: str

    The decoding process involves:
    1. Extracting Padding Information: The number of padding bits is determined from the first character
        of the base2p15 string.
    2. Decoding 15-bit Segments: For each character in the string (excluding the first and last), 
        it is converted from its ASCII value to a 15-bit binary string.
    3. Handling the Final Segment: The last character is processed similarly but is truncated according 
        to the padding information to obtain the correct length for the final segment.
    4. Concatenation: All decoded 15-bit segments are concatenated together to form the final binary string.
    """
    $PlaceHolder$


def base2p15_get_range(base2p15: str, start: int, end: int) -> str:
    """
    Get a range of bits from [start,end)

    :param base2p15: A base2p15 string generated by base2p15_encode
    :type base2p15: str
    :param start: Starting number (inclusive)
    :type start: int
    :param end: End number (exclusive)
    :type end: int
    :returns: A binary string e.g. 00001001
    :rtype: str
    """
    assert start < end
    assert start >= 0
    assert end < (len(base2p15) - 1) * 15 - int(base2p15[0], 16) + 1
    range_str = base2p15[1:][start // 15:(end // 15) + 1]
    end_pad = hex(15 - end % 15)[2:]
    start_pad = start % 15
    d = base2p15_decode(end_pad + range_str)[start_pad:]
    return d
